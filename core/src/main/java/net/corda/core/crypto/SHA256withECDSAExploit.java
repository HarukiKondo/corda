package net.corda.core.crypto;

//import sun.security.util.SignatureUtil;

import net.i2p.crypto.eddsa.EdDSASecurityProvider;
import org.bouncycastle.jce.ECNamedCurveTable;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.jce.spec.ECNamedCurveParameterSpec;

import java.security.*;

public class SHA256withECDSAExploit {

    public static void main(String[] args) throws Exception {


        Provider[] providers = Security.getProviders();

        Signature signature = Signature.getInstance("SHA256withECDSA");

        assert(signature != null);
//        AlgorithmParameters algoParams = AlgorithmParameters.getInstance(signature.getAlgorithm());

        //SignatureUtil.specialSetParameter();


        BouncyCastleProvider cordaBouncyCastleProvider = new BouncyCastleProvider();
        cordaBouncyCastleProvider.putAll(new EdDSASecurityProvider());
        cordaBouncyCastleProvider.put("AlgorithmParameters.SHA256WITHECDSA", AlgorithmParametersSpi.class.getName());

        Security.addProvider(cordaBouncyCastleProvider);

        /*
        cordaBouncyCastleProvider.put("Signature." + EdDSAEngine.SIGNATURE_ALGORITHM, X509EdDSAEngine::class.java.name)

                .apply {
            // Override the normal EdDSA engine with one which can handle X509 keys.
            put("Signature.${EdDSAEngine.SIGNATURE_ALGORITHM}", X509EdDSAEngine::class.java.name)
            addKeyInfoConverter(`id-Curve25519ph`, object : AsymmetricKeyInfoConverter {
                override fun generatePublic(keyInfo: SubjectPublicKeyInfo) = decodePublicKey(EDDSA_ED25519_SHA512, keyInfo.encoded)
                override fun generatePrivate(keyInfo: PrivateKeyInfo) = decodePrivateKey(EDDSA_ED25519_SHA512, keyInfo.encoded)
            })
        }.also {
            // This registration is needed for reading back EdDSA key from java keystore.
            // TODO: Find a way to make JKS work with bouncy castle provider or implement our own provide so we don't have to register bouncy castle provider.
            Security.addProvider(it)
        }
        */

        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("ECDSA", cordaBouncyCastleProvider.getName());
        ECNamedCurveParameterSpec curveSpec = ECNamedCurveTable.getParameterSpec("secp256r1");
        keyPairGenerator.initialize(curveSpec); // TODO: May need Corda Secure Random

        KeyPair keyPair = keyPairGenerator.generateKeyPair();
        assert(keyPair != null);

        /*
        CertificateFactory cf = CertificateFactory.getInstance("X.509");
        X509Certificate trustRoot = (X509Certificate)cf.generateCertificate(inStream);
        TrustAnchor trustAnchor = new TrustAnchor(trustRoot, null);
        CertPath certPath = null;
        PKIXParameters parameters = new PKIXParameters(Collections.singleton(trustAnchor));

        CertPathValidatorResult validationResult = CertPathValidator.getInstance("PKIX").validate(certPath, parameters);
        assert(validationResult != null);
        */
    }
}
